const integerToLetter = (n) => {
  if (typeof n !== 'number' || n < 0 || !Number.isInteger(n)) {
    return null
  }
  if (n === 0) return 0
  let result = ''
  while (n > 0) {
    const remainder = (n - 1) % 26
    result = String.fromCharCode(65 + remainder) + result
    n = Math.floor((n - 1) / 26)
  }
  return result
}

const calculateCellRange = (start, end) => {
  if (start === end) return [start]

  const parseCoordinates = (coord) => {
    const match = coord.match(/([A-Z]*)([0-9]+)/)
    const [, column, row] = match
    let columnNumeric
    if (column === '') {
      columnNumeric = 0
    } else {
      columnNumeric = column.split('').reduce((acc, char) => acc * 26 + char.charCodeAt(0) - 64, 0)
    }
    return { column: columnNumeric, row: parseInt(row, 10)}
  }

  const startCell = parseCoordinates(start)
  const endCell = parseCoordinates(end)

  if (startCell === null || endCell === null) return null

  const smallerColumn = startCell.column < endCell.column ? startCell.column : endCell.column
  const largerColumn = startCell.column >= endCell.column ? startCell.column : endCell.column
  const smallerRow = startCell.row < endCell.row ? startCell.row : endCell.row
  const largerRow = startCell.row >= endCell.row ? startCell.row : endCell.row

  const result = []
  for (let r = smallerRow; r <= largerRow; r++) {
    for (let c = smallerColumn; c <= largerColumn; c++) {
      if (c !== 0 && r !== 0) {
        result.push(`${integerToLetter(c)}${r}`)
      }
    }
  }
  return result
}

const terrainColorMap = {
  'plains': '#d9ead3',
  'forest': '#6aa84f',
  'mud': '#b46006',
  'jungle': '#274e13',
  'undergrowth': '#38761d',
  'marsh': '#134f5c',
  'high-ground': '#ffffff', // TBD
  'shallow-water': '#c9daf8',
  'deep-water': '#3c78d8',
  'fire': 'ffffff', // TBD
  'road': '#999999'
}

const findClosestFreeTile = (board, coordinates, rowNumber, columnNumber) => {
  // Function generated by ChatGPT
  const parseCoordinates = (coord) => {
    const match = coord.match(/([A-Z]+)([0-9]+)/)
    const [, column, row] = match
    const columnNumeric = column.split('').reduce((acc, char) => acc * 26 + char.charCodeAt(0) - 64, 0)
    return { column: columnNumeric, row: parseInt(row, 10) }
  }

  const directions = [
    { dx: -1, dy: 0 },  // top
    { dx: 0, dy: 1 },   // right
    { dx: 1, dy: 0 },   // bottom
    { dx: 0, dy: -1 },  // left
    { dx: -1, dy: 1 },  // top right
    { dx: 1, dy: 1 },   // bottom right
    { dx: 1, dy: -1 },  // bottom left
    { dx: -1, dy: -1 }  // top left
  ]

  const start = parseCoordinates(coordinates)

  // Check if the starting tile is free
  if (!board[coordinates] || board[coordinates].unitFullCode === '') {
      return coordinates // The starting tile is free, return it
  }

  const queue = [{ column: start.column, row: start.row }]
  const visited = new Set([coordinates])

  while (queue.length > 0) {
      const { column, row } = queue.shift()

      for (const { dx, dy } of directions) {
          const newColumn = column + dx
          const newRow = row + dy

          // Skip invalid coordinates (out of bounds)
          if (newColumn <= 0 || newRow <= 0 || newColumn > columnNumber || newRow > rowNumber) {
              continue
          }

          const newCoordinate = `${integerToLetter(newColumn)}${newRow}`

          if (!visited.has(newCoordinate)) {
              visited.add(newCoordinate)

              if (!board[newCoordinate] || board[newCoordinate].unitFullCode === '') {
                  return newCoordinate // Found the closest free tile
              }

              queue.push({ column: newColumn, row: newRow })
          }
      }
  }

  return null // No free tile found
}

const colorGroups = [
  ['Red', 'DarkRed', 'LightCoral', 'FireBrick', 'Crimson', 'IndianRed', 'LightSalmon', 'Salmon', 'DarkSalmon', 'Red'],
  ['Blue', 'RoyalBlue', 'DodgerBlue', 'DeepSkyBlue', 'SkyBlue', 'SteelBlue', 'LightSteelBlue', 'LightSkyBlue', 'PowderBlue', 'AliceBlue'],
  ['Green', 'DarkGreen', 'ForestGreen', 'SeaGreen', 'MediumSeaGreen', 'LightSeaGreen', 'PaleGreen', 'SpringGreen', 'LimeGreen', 'Lime'],
  ['Yellow', 'Gold', 'Khaki', 'LightGoldenRodYellow', 'LemonChiffon', 'LightYellow', 'PapayaWhip', 'Moccasin', 'PeachPuff', 'PaleGoldenRod'],
  ['Orange', 'DarkOrange', 'Coral', 'Tomato', 'Orangered', 'Salmon', 'LightCoral', 'SandyBrown', 'Peru', 'Chocolate'],
  ['Purple', 'DarkViolet', 'MediumPurple', 'BlueViolet', 'DarkOrchid', 'Orchid', 'MediumOrchid', 'Plum', 'Violet', 'Thistle'],
  ['Cyan', 'LightCyan', 'Aqua', 'Turquoise', 'MediumTurquoise', 'DarkTurquoise', 'CadetBlue', 'DarkSlateGray', 'LightSeaGreen', 'DarkCyan'],
  ['Magenta', 'Fuchsia', 'Orchid', 'MediumOrchid', 'DarkOrchid', 'BlueViolet', 'Purple', 'DarkViolet', 'SlateBlue', 'MediumSlateBlue'],
  ['Brown', 'SaddleBrown', 'Sienna', 'Peru', 'RosyBrown', 'Moccasin', 'PeachPuff', 'Tan', 'GoldenRod', 'Wheat'],
  ['Gray', 'DarkGray', 'Silver', 'LightGray', 'Gainsboro', 'WhiteSmoke', 'White', 'Black', 'DimGray', 'Charcoal']
];

// Function to get a random color from the next group
const getRandomColorFromGroup = (usedColors, group) => {
  let color;
  let attempts = 0;

  do {
      color = group[Math.floor(Math.random() * group.length)];
      attempts++;
  } while (usedColors.includes(color) && attempts < group.length);

  return color;
};

// Main function to assign a user color
const assignUserColor = (users) => {
  const usedColors = users.map(user => user.userColor);
  const groupCount = colorGroups.length;

  // Determine the next group index based on the number of users
  const currentGroupIndex = users.length % groupCount;

  const group = colorGroups[currentGroupIndex];
  const color = getRandomColorFromGroup(usedColors, group);

  return color;
};

module.exports = {
  integerToLetter,
  calculateCellRange,
  terrainColorMap,
  findClosestFreeTile,
  assignUserColor
}
